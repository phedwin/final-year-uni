
#include "common.h"

FUNCTION(_start)
    
    if (argc < 3)
		progname == NULL ? TAG_USAGE(argv[0], stderr)
				 : TAG_USAGE(progname, stderr);

	char *filename = 0, *path = 0;
	int opts;
	while ((opts = getopt(argc, argv, SHORTOPTS)) != -1) {
		switch (opts) {
				/*case 'a' usage is bin -a [FILE] [....TAGS]*/
			case 'a': {
				/*optarg is the file user wanted to write the
				 * tags on, & its mostly the path u provide.*/
				filename = optarg;
				/* TempFile Generated, we decided with a
				 * markdown, its easy to write and parse, no
				 * extra work like parsing imagining if we had
				 * either json or toml, which were better
				 * choices */
				path = generateTempTagFile();
				if (path == 0)
					return EXIT_FAILURE;

				/*the idea is if we get the flag option
				 * for add and then we need the extra
				 * filepath to write the changes u made,
				 * in that we have the fd, & also that;
				 * i thought open was better & maybe we
				 * can move to fopen */
				int fd_src, fd_dst;

				fd_src = open(path, MODE, FILE_MODE);
				fd_dst = open(filename, MODE, FILE_MODE);
				if (fd_src < 0 || fd_dst < 0)
					return EXIT_FAILURE;
				// keeping everything under 4K
#define BUF MAXLINE
				if (ftruncate(fd_src, 4096))
					return EXIT_FAILURE;
				char buf[BUF];
				/*Tags are added to the temp file first, This is
				 * the idea i had, something like journal, so we
				 * can always have a good failover and incase it
				 * fails to write then the user file is safe
				 * (this is lowkey stupid now that im thinking
				 * about it ) its not like its going to fail*/
				addTagsToTheFile(path, argv, argc);

				/*writing to the temporary file, autogenerated*/
				persistToFile(fd_src, buf, sizeof buf, argc);

				/* if the write was successful, save to disk,
				 * TODO sync write changes, close buffers and
				 * setvbuf to line buf
				 * setvbuf(stream, buf, _IOLBF, BUF); */

				void *mem = copyOverSharedMem(fd_src, fd_dst);
				/* release mapped mem*/
				munmap(mem, 4096);
				/*unlink the journal*/
				remove(path);
				/*success copy to disk ? */
				if (fsync(fd_dst) < 0)
					return errno;

				/* clean everything*/
				close(fd_dst);
				close(fd_src);
			} break;
				/*search tags*/
			case 's': {
			} break;

				/*search by filename*/
			case 't': {
			} break;
			case '?':
				COMMON_TODO("unimplemented!")
				break;
		}
	}

	free(path);